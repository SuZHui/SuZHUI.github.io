{"componentChunkName":"component---src-template-blog-post-js","path":"/article/BFE1A715482A3D29","result":{"data":{"markdownRemark":{"html":"<h2>TypeScript是什么</h2>\n<blockquote>\n<p>TypeScript是JavaScript的一个超集,主要提供了<code>类型系统</code>和对<code>ES6</code>的支持,可编译成纯JavaScript。\n它由Microsoft开发，代码开源在<a href=\"https://github.com/Microsoft/TypeScript\">GitHub</a>上。</p>\n</blockquote>\n<h2>为什么选择TypeScript</h2>\n<h3>TypeScript 增加了代码的可读性和可维护性</h3>\n<ul>\n<li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li>\n<li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li>\n<li>增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等</li>\n</ul>\n<h3>TypeScript 非常包容</h3>\n<ul>\n<li>TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可</li>\n<li>即使不显式的定义类型，也能够自动做出类型推论</li>\n<li>可以定义从简单到复杂的几乎一切类型</li>\n<li>即使 TypeScript 编译报错，也可以生成 JavaScript 文件</li>\n<li>兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取</li>\n</ul>\n<h3>TypeScript 拥有活跃的社区</h3>\n<ul>\n<li>大部分第三方库都有提供给 TypeScript 的类型定义文件</li>\n<li>Google 开发的 Angular2 就是使用 TypeScript 编写的</li>\n<li>TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范</li>\n</ul>\n<h3>TypeScript 的缺点</h3>\n<p>任何事物都是有两面性的，我认为 TypeScript 的弊端在于：</p>\n<ul>\n<li>有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念</li>\n<li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本</li>\n<li>集成到构建流程需要一些工作量</li>\n<li>可能和一些库结合的不是很完美</li>\n</ul>\n<h2>在前端项目中使用TypeScript</h2>\n<p>以下只列举一些开发中用到的功能，详细的TS指南可以查看<a href=\"https://www.tslang.cn/\">官方文档</a></p>\n<h3>对api模块的改造</h3>\n<p>下面是对一个api模块的改造，对原有的接口入参和返回做了类型定义，这样在进行开发和维护时，只要查看这些类型定义，就可以快速的获取该接口返回的正确数据类型。方便下一步的本地数据使用和业务逻辑处理。</p>\n<p>改造前</p>\n<pre><code class=\"language-js\">import { http } from '@plugin/http'\nexport default {\n  /**\n   * 获取可配置的权限列表\n   */\n  getConfigurablePermissionList (companyId = null) {\n    return http('/menu/getMenu', { companyId })\n  }\n}\n</code></pre>\n<p>改造后</p>\n<pre><code class=\"language-ts\">import { http } from '@plugin/http'\nimport { PermissionData } from '@type/response'\n\ninterface IBaseResponse {\n  code: number,  \n  data: PermissionData,\n  msg: string | nulls\n}\n\nexport default {\n  /**\n   * 获取可配置的权限列表\n   */\n  getConfigurablePermissionList (companyId: number | null)\n  : Promise&#x3C;IBaseResponse>\n  {\n    return http('/menu/getMenu', { companyId })\n  }\n}\n</code></pre>\n<h3>对组件及业务的类型校检进行改造</h3>\n<p>对函数进行参数校验，对参数和变量进行了强类型约束，在编码阶段就能获得对应的类型提示，避免了很多在运行时才能发现的类型错误。</p>\n<p>改造前</p>\n<pre><code class=\"language-js\">const STATE = {\n  TO_BE_DONE: 0,\n  DOING:1,\n  DONE: 2\n}\n\nfunction useState (state) {\n  if (state &#x26;&#x26; state.DOING &#x26;&#x26; state.DOING === 1) {\n    // 进行业务代码的编写...\n  }\n}\n\nuseState(STATE.DOING)\n</code></pre>\n<p>改造后</p>\n<pre><code class=\"language-ts\">// 定义枚举\nconst enum STATE {\n  TO_BE_DONE = 0,\n  DOING = 1,\n  DONE = 2\n}\n\nfunction useState (state: STATE): void {\n  if (state === STATE.DOING) {\n    // 直接进行业务代码的编写...\n  }\n}\n\nuseState(STATE.DOING)\n</code></pre>\n<p>其它常见的问题就是涉及严格的空值检查，即使用属性来构造或尝试调用可能为 null 或 undefined 的内容，在编码阶段就能获得IDE的警告。\n另一种是变量类型不匹配的问题，当我们尝试使用彼此不匹配的类型时,同样在开发阶段TypeScript就会提示我们，从而在上线之前减少这类bug的出现。</p>\n<h2>写在最后</h2>\n<p>目前Vue（2.x）与TS的契合度不够好，如果只是练手不建议直接在生产中使用。Vue 3.x出来之后将会更好的支持TS（尤小佑说的），可以在3.x出来前在自己的小项目里多玩玩<code>TS</code> 和 <code>React hooks</code> 。</p>","frontmatter":{"date":"December 18, 2019","path":"/article/BFE1A715482A3D29","title":"在项目中使用TypeScript"}},"site":{"siteMetadata":{"title":"Just A Little","description":"just a little blog","author":"@SuZHui <https://github.com/SuZHui>"}}},"pageContext":{}},"staticQueryHashes":["4224293195"]}